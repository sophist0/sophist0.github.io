<html>
<head>
<title>Crypto Notes</title>
<link rel="stylesheet" type="text/css" href="crypto_style.css">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div class="hspacer"></div>
<div class="content_block">
<h1>Crypto Notes</h1>
<hr>
<p>
The goal of these notes is to serve as a record of my own understanding of crypto currencies and related concepts. I find writing formal notes forces me to confront gaps in my understanding. Also I personally do not invest in crypto currencies as I cannot afford to lose the money and I do not suggest that anyone else should except for educational purposes. What interests me about crypto currencies is not so much their value but their relative success as persistent distributed applications. These notes no doubt reflect this interest.
</p>
<p>
I had also hoped that GitHub Pages had some great whizzbang plug and play templates which would make my notes look pro! Not so much, so bear with me as I refine there presentation.
</p>

<h2>Preliminary Concepts</h2>
<hr>
<p>
<h3>Hash Function</h3>
A hash function is a function that,
<ol>
	<li>Maps a message m of arbitrary size to a fixed size hash value, $hash(m)$.</li>
	<li>Scrambles the information in m such that the hash functions hash value is uniformly distributed across its possible values.</li>
	<li>Is fast to compute.</li>
	<li>Is deterministic.</li>
</ol>

Notice that 2. leads to a corollary,
<ul>
<li>A hash function minimizes the probability that two distinct messages $m_1$ and $m_2$ have the same hash value. Which can be formally expressed as minimizing the probability that,
$$
m_1 \neq m_2 	\hspace{2em} \text{and} \hspace{2em} 	hash(m_1) = hash(m_2)
$$
</li>
</ul>

This is a corollary of 2. because 2. states that hash(m) for any message m is uniformly distributed over all possible hash values. Additionally it is called a hash collision if it is true that $m_1 \neq m_2$ and $hash(m_1) = hash(m_2)$.
</p>
<p>
An example of a simple hash function is,<br>
<img src="images/hash_func.png"><br>

Assuming the input message is a string of alphabetic characters this simple hash function outputs an integer between 0 and 4. So if we input messages ALICE and BOB into this hash function we get hashes 0 and 4 as shown in the table below.
</p>
<table style="width:100%">
	<tr class="col_label">
    	<th>Input</th>
    	<th>Current Char.</th> 
    	<th>Char. to Dec.</th>
	<th>(+)</th>
	<th>mod 5</th>
	<th>Output</th>
  	</tr>
	<tr>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
  	</tr>
	<tr>
    	<th>ALICE</th>
    	<th>A</th>
    	<th>1</th>
    	<th>1</th>
    	<th>1</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>L</th>
    	<th>12</th>
    	<th>13</th>
    	<th>3</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>I</th>
    	<th>9</th>
    	<th>12</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>C</th>
    	<th>3</th>
    	<th>5</th>
    	<th>0</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>E</th>
    	<th>5</th>
    	<th>10</th>
    	<th>0</th>
    	<th>0</th>
  	</tr>
	<tr>
    	<th>BOB</th>
    	<th>B</th>
    	<th>2</th>
    	<th>2</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>O</th>
    	<th>15</th>
    	<th>17</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>B</th>
    	<th>2</th>
    	<th>4</th>
    	<th>4</th>
    	<th>4</th>
  	</tr>
</table>
<p>
<b>Notation:</b> (+) denotes addition, mod denotes the modulo operation<br>
<b>Source:</b> en.wikipedia.org/wiki/Hash_function
</p>
<hr>


<div class="hspacer"></div>
<p>
<h3>Cryptographic Hash Function</h3>
The fundamental difference between a hash function and a cryptographic hash function is that it is practically impossible to invert a cryptographic hash function, which is a one-way function. In life there are many one-way functions. For instance it is easy to light a match, but once lit it is practically impossible to return it to its initial state.
</p>
<p>
In the example hash function above, the inability to invert it would imply that given the hash value $0$ it is impossible to guess that it was derived from the message ALICE. This is clearly not true which is why the hash function above is not a cryptographic hash function.
</p>
Getting more technical a cryptographic hash function should satisfy the following properties.
<ul>
<li>
<b>Pre-image resistance:</b>
Given a hash value $h$ it should be difficult to find a message $m$ such that,
$$
h = hash(m)
$$
</li>
<li>
<b>Second pre-image resistance:</b>
Given an input $m_1$, it should be difficult to find a different input $m_2$ such that,
$$
hash(m_1) = hash(m_2)
$$
</li>
<li>
<b>Collision resistance:</b>
It should be difficult to find two different messages $m_1$ and $m_2$ such that.
$$
hash(m_1) = hash(m_2)
$$
</li>
</ul>
<p>
<b>Source:</b> en.wikipedia.org/wiki/Cryptographic_hash_function
</p>
<hr>


<div class="hspacer"></div>
<p>
<h3>Symmetric-Key Cryptography</h3>
To motivate public-key cryptography I’m going to introduce symmetric key cryptography. In symmetric key cryptography the same secret key is used to both encode and decode a message. One of the simplest symmetric key ciphers is the Caesar shift cipher. Given a message text m and secret key $k$, the message with spaces removed and letters replaced by the integers $1$ through $26$ is encoded as
$$
c = (m+k)~mod~26
$$
and is decoded as
$$
\begin{align}
(c-k)~mod~26&
= ((m+k)~mod~26 -k)~mod~26\\
&= (m+k)-k)~mod~26\\
&= m~mod~26\\
&= m
\end{align}
$$
For example say Alice wants to send Bob the message 
$$
bewareofbrutus
$$
using a Caesar shift cipher and the shared secret key $k=1$. The corresponding encoded message or ciphertext is
$$
cfxbsfpgcsvuvt
$$
as each character in the message is replaced by the character $1$ space to its left in the alphabet and wrapping around at ‘z’.  Bob knowing $k=1$ can then decode this ciphertext by replacing each character with the character one space to its right and wrapping around at ‘a’.
</p>
<p>
The Caesar shift cipher is a very simple encryption scheme. Practical symmetric cryptography schemes like Advanced Standard Encryption (AES) are much more complicated. But the key takeaway is for Alice and Bob to communicate in a symmetric cryptography scheme they must share a secret key.
</p>
<p>
Now let's say Alice and Bob have a friend Tom. If Alice wants to communicate privately with Bob they must share a secret key $k_{AB}$ and if Alice wants to communicate privately with Bob they must share a secret key $k_{AT}$. Finally if Bob wants to communicate privately with Tom they must share a secret key $k_{BT}$. This in only three secret keys but say there are $n$ people who want to communicate then under a symmetric cryptography scheme each user would have to have $n-1$ unique secret keys and in the entire cryptography scheme would have to generate and maintain,
$$
\frac{n (n-1)}{2}
$$
secret keys. So if $n$ is earth’s population which is about $7.5 \times 10^9$ that works out to about $2.8 \times 10^{19}$ secret keys, which becomes a challenge to generate and maintain.
</p>
<p>
Of course most people don’t communicate with every other person on earth. So why is it necessary to generate all n (n-1) / 2 keys? The short answer is that it is not necessary thanks to public-key cryptography. But let’s give an example where it might otherwise be necessary to generate all these keys.
</p>
<p>
Say Alice, Bob, and Tom want to communicate privately with one another. How do they distribute keys $k_{AB}$, $k_{AT}$, and $k_{BT}$? Perhaps Alice chooses $k_{AB}$ and $k_{AT}$ and gives them to Bob and Tom in super secret meet ups. But clearly if Alice wants to communicate with $n$ people, meeting all of them in person to give them a secret key is not practical. So instead Alice mails Bob and Tom their secret keys, eliminating the need for super secret meet ups. But Tom is curious about Alice’s private communications with Bob, so Tom intercepts the letter and copies the secret key $k_{AB}$ before forwarding it to Bob. Tom is then able to read all of Alice and Bob’s communications without either of them knowing that he is doing so. This of course undermines the entire reason for setting up a cryptographic communication scheme in the first place.
</p>
<p>
So instead say Alice, Bob, and Tom appeal to a trusted party, Server. Server generates all the secret keys and is always available for super secret meet ups to hand them off in person. The first problem with this distribution scheme is that in the worst case Server will have to generate and maintain $\frac{n(n-1)}{2}$ keys to make sure that he doesn’t accidentally distribute a key to more than one pair of users. The second problem is can Alice, Bob, and Tom really trust Server? Server can read everyone's messages. Again this seems to undermine the entire reason for using a cryptographic communication scheme.
</p>
<p>
Public-key cryptography while much more computationally intensive than symmetric key cryptography avoids the problem of exchanging secret keys entirely. In fact public-key cryptographic schemes are often used to set up secure communication channels via which individuals initially exchange secret keys for symmetric key cryptography schemes.
</p>
<p>
<b>Sources:</b> en.wikipedia.org/wiki/Caesar_cipher
</p>
<hr>

<div class="hspacer"></div>
<p>
<h3>Public-key cryptography</h3>
So how does public-key encryption work? Imagine for a moment that Alice and Bob each generate a pair of keys for themselves, a public key $k_{pub}$ which they send to anyone who requests it and a private key $k_{pri}$ which is known only to them. If Alice wants to send Bob an encrypted message $m$ she encrypts it with Bob’s public key $k_{b,pub}$.
$$
c = encrypt(m,k_{b,pub})
$$

Bob on receiving $c$, decrypts it using his private key $k_{b,pri}$.
$$
m = decrypt(c,k_{b,pri})
$$
</p>
<p>
An elegant solution to the problem of key distribution. Why did it take until the 1970s for James H. Ellis to discover public-key cryptography when symmetric key cryptography has been around for thousands of years? Well it turns out that choosing the right public and private key pairs and the right encryption and decryption algorithms of that if an attacker known $k_{pub}$, $encrypt(*)$, $decrypt(*)$, and ciphertext $c$, they cannot easily guess $k_{pri}$ or message m is non-trivial.
</p>
<p>
To see this I will explain how Rivest–Shamir–Adleman (RSA) public-key cryptosystem works. But first let’s introduce the modular congruence.  Modular congruence is a relation denoted as
$$
a \equiv b~(mod~n)
$$
Where $a-b = kn$ for some integer $k$. For instance
$$
\begin{align}
2 &≡ 2~(mod~5)\\
7 &≡ 2~(mod~5)\\
12 &≡ 2~(mod~5)\\
etc.
\end{align}
$$
This is slightly different than stating equality after the modulo operation. For instance, $12~mod~5 = 2$.
</p>
<p>
The basic idea of RSA is to select three large integers $e$, $d$, and $n$. Then given a message text $m$ convert it into binary and then into its corresponding integer representation. If $m \geq n$ slice up the original message until $0 \leq m < n$.
</p>
<p>
The public key is $e$ and $n$ and the encryption function is defined as
$$
c \equiv m^e~(mod~n)
$$
The private key is $d$ and the decryption function is defined as
$$
\begin{align}
c^d~(mod~n) &= (m^e~(mod~n))^d~(mod~n)\\
&= m^{ed}~(mod~n)\\
&\equiv m
\end{align}
$$
</p>
<p>
To understand why the $m$ is congruent with $m^{ed}~(mod~n)$ requires understanding how $n$, $e$, and $d$ are selected. Trappe summarized this selection processes as follows
<ol>
<li>Choose secret primes $p$ and $q$ and computes $n = pq$.</li>
<li>Choose $e$ with $gcd(e,(p-1)(q-1)) = 1$.</li>
<li>Compute $d$ such that $de ≡ 1~(mod~(p-1)(q-1))$.</li>
</ol>
</p>
<p>
Now although it can be shown to be unnecessary, assume $gcd(m,n) = 1$. Then Euler’s Theorem gives
$$
m\phi(n) \equiv 1~(mod~n)
$$
where $\phi(n)$ Euler totient function and given $n = pq$ it follows that $\phi(n) = (p-1)(q-1)$.
</p>
<p>
Now recall we also selected $d$ such that $d^e ≡ 1~(mod~(p-1)(q-1))$. Therefore it follows that $d^e = 1 + k\phi(n)$ for some integer $k$ and,
$$
\begin{align}
c^d &\equiv (m^e)^d~(mod~n)\\
&\equiv m^{1+kφ(n)}~(mod~n)\\	
&\equiv m(m^{\phi(n)})^k~(mod~n)\\		
&\equiv m(1)^k~(mod~n) \hspace{4em} \text{from Euler’s Theorem}\\
&\equiv m
\end{align}	
$$
</p>
<p>
Now why is RSA secure? First it is hard to guess the message $m$ given ciphertext $m^e$. Second given $e$ and $n$ its hard to compute $d$ because $n$ is hard to factor into $p$ and $q$. Where by hard we mean there is no known algorithm that can factor a $b$-bit number in $O(bk)$ time or less for some constant $k$.
</p>
<p>
<b>Sources:</b><br> 
en.wikipedia.org/wiki/Public-key_cryptography<br>
en.wikipedia.org/wiki/Modular_arithmetic<br>
en.wikipedia.org/wiki/RSA_(cryptosystem)<br>
en.wikipedia.org/wiki/Integer_factorization<br>
en.wikipedia.org/wiki/Big_O_notation<br>
Introduction to Cryptography with Coding Theory by Wade Trappe and Lawrence Washington
</p>
<hr>

<div class="hspacer"></div>
<p>
<h3>Digital Signatures</h3>
<p>
Once you understand the concepts of public-key cryptography digital signatures are pretty straight forward. Say Alice wants to send Bob a message m and she doesn’t care who reads it she just wants Bob to know it was from her. Then she would sign the message with her private key d. Anyone with Alice’s public key $(e,n)$ could of course recover the message but they would also know that only Alice had the secret d with which the message was signed therefore it must be from her. Under the RSA cryptosystem this digital signature has the form,
$$
m_{signed} = m^d
$$
</p>
<p>
Signature verification is the same procedure as public key encryption.
$$
(m_{signed})^e \equiv (m^d)^e~(mod~n)\\
\equiv m^{ed}~(mod~n)\\
\equiv m
$$
</p>
<p>
<b>Sources:</b><br>
en.wikipedia.org/wiki/Public-key_cryptography<br>
en.wikipedia.org/wiki/Modular_arithmetic<br>
Introduction to Cryptography with Coding Theory by Wade Trappe and Lawrence Washington
</p>
<hr>
<div class="hspacer"></div>
</div>
</body>
</html>
