<html>
<head>
<title>Crypto Notes</title>
<link rel="stylesheet" type="text/css" href="crypto_style.css">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div class="hspacer"></div>
<div class="content_block">
<h1>Crypto Notes</h1>
<hr>
<p>
The goal of these notes is to serve as a record of my own understanding of crypto currencies and related concepts. I find writing formal notes forces me to confront gaps in my understanding. Also I personally do not invest in crypto currencies as I cannot afford to lose the money and I do not suggest that anyone else should except for educational purposes. What interests me about crypto currencies is not so much their value but their relative success as persistent distributed applications. These notes no doubt reflect this interest.
</p>
<p>
I had also hoped that GitHub Pages had some great whizzbang plug and play templates which would make my notes look pro! Not so much, so bear with me as I refine there presentation.
</p>

<h2>Preliminary Concepts</h2>
<hr>
<p>
<h3>Hash Function</h3>
A hash function is a function that,
<ol>
	<li>Maps a message m of arbitrary size to a fixed size hash value, $hash(m)$.</li>
	<li>Scrambles the information in m such that the hash functions hash value is uniformly distributed across its possible values.</li>
	<li>Is fast to compute.</li>
	<li>Is deterministic.</li>
</ol>

Notice that 2. leads to a corollary,
<ul>
<li>A hash function minimizes the probability that two distinct messages $m_1$ and $m_2$ have the same hash value. Which can be formally expressed as minimizing the probability that,
$$
m_1 \neq m_2 	\hspace{2em} \text{and} \hspace{2em} 	hash(m_1) = hash(m_2)
$$
</li>
</ul>

This is a corollary of 2. because 2. states that hash(m) for any message m is uniformly distributed over all possible hash values. Additionally it is called a hash collision if it is true that $m_1 \neq m_2$ and $hash(m_1) = hash(m_2)$.
</p>
<p>
An example of a simple hash function is,<br>
<img src="images/hash_func.png"><br>

Assuming the input message is a string of alphabetic characters this simple hash function outputs an integer between 0 and 4. So if we input messages ALICE and BOB into this hash function we get hashes 0 and 4 as shown in the table below.
</p>
<table style="width:100%">
	<tr class="col_label">
    	<th>Input</th>
    	<th>Current Char.</th> 
    	<th>Char. to Dec.</th>
	<th>(+)</th>
	<th>mod 5</th>
	<th>Output</th>
  	</tr>
	<tr>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
  	</tr>
	<tr>
    	<th>ALICE</th>
    	<th>A</th>
    	<th>1</th>
    	<th>1</th>
    	<th>1</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>L</th>
    	<th>12</th>
    	<th>13</th>
    	<th>3</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>I</th>
    	<th>9</th>
    	<th>12</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>C</th>
    	<th>3</th>
    	<th>5</th>
    	<th>0</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>E</th>
    	<th>5</th>
    	<th>10</th>
    	<th>0</th>
    	<th>0</th>
  	</tr>
	<tr>
    	<th>BOB</th>
    	<th>B</th>
    	<th>2</th>
    	<th>2</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>O</th>
    	<th>15</th>
    	<th>17</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>B</th>
    	<th>2</th>
    	<th>4</th>
    	<th>4</th>
    	<th>4</th>
  	</tr>
</table>
<p>
<b>Notation:</b> (+) denotes addition, mod denotes the modulo operation<br>
<b>Source:</b> en.wikipedia.org/wiki/Hash_function
</p>
<hr>


<div class="hspacer"></div>
<p>
<h3>Cryptographic Hash Function</h3>
The fundamental difference between a hash function and a cryptographic hash function is that it is practically impossible to invert a cryptographic hash function, which is a one-way function. In life there are many one-way functions. For instance it is easy to light a match, but once lit it is practically impossible to return it to its initial state.
</p>
<p>
In the example hash function above, the inability to invert it would imply that given the hash value $0$ it is impossible to guess that it was derived from the message ALICE. This is clearly not true which is why the hash function above is not a cryptographic hash function.
</p>
Getting more technical a cryptographic hash function should satisfy the following properties.
<ul>
<li>
<b>Pre-image resistance:</b>
Given a hash value $h$ it should be difficult to find a message $m$ such that,
$$
h = hash(m)
$$
</li>
<li>
<b>Second pre-image resistance:</b>
Given an input $m_1$, it should be difficult to find a different input $m_2$ such that,
$$
hash(m_1) = hash(m_2)
$$
</li>
<li>
<b>Collision resistance:</b>
It should be difficult to find two different messages $m_1$ and $m_2$ such that.
$$
hash(m_1) = hash(m_2)
$$
</li>
</ul>
<p>
<b>Source:</b> en.wikipedia.org/wiki/Cryptographic_hash_function
</p>
<hr>


<div class="hspacer"></div>
<p>
<h3>Symmetric-key cryptography</h3>
To motivate public-key cryptography I’m going to introduce symmetric key cryptography. In symmetric key cryptography the same secret key is used to both encode and decode a message. One of the simplest symmetric key ciphers is the Caesar shift cipher. Given a message text m and secret key $k$, the message with spaces removed and letters replaced by the integers $1$ through $26$ is encoded as
$$
c = (m+k)~mod~26
$$
and is decoded as
$$
\begin{align}
(c-k)~mod~26&
= ((m+k)~mod~26 -k)~mod~26\\
&= (m+k)-k)~mod~26\\
&= m~mod~26\\
&= m
\end{align}
$$
For example say Alice wants to send Bob the message 
$$
bewareofbrutus
$$
using a Caesar shift cipher and the shared secret key $k=1$. The corresponding encoded message or ciphertext is
$$
cfxbsfpgcsvuvt
$$
as each character in the message is replaced by the character $1$ space to its left in the alphabet and wrapping around at ‘z’.  Bob knowing $k=1$ can then decode this ciphertext by replacing each character with the character one space to its right and wrapping around at ‘a’.
</p>
<p>
The Caesar shift cipher is a very simple encryption scheme. Practical symmetric cryptography schemes like Advanced Standard Encryption (AES) are much more complicated. But the key takeaway is for Alice and Bob to communicate in a symmetric cryptography scheme they must share a secret key.
</p>
<p>
Now let's say Alice and Bob have a friend Tom. If Alice wants to communicate privately with Bob they must share a secret key $k_{AB}$ and if Alice wants to communicate privately with Bob they must share a secret key $k_{AT}$. Finally if Bob wants to communicate privately with Tom they must share a secret key $k_{BT}$. This in only three secret keys but say there are $n$ people who want to communicate then under a symmetric cryptography scheme each user would have to have $n-1$ unique secret keys and in the entire cryptography scheme would have to generate and maintain,
$$
\frac{n (n-1)}{2}
$$
secret keys. So if $n$ is earth’s population which is about $7.5 \times 10^9$ that works out to about $2.8 \times 10^{19}$ secret keys, which becomes a challenge to generate and maintain.
</p>
<p>
Of course most people don’t communicate with every other person on earth. So why is it necessary to generate all n (n-1) / 2 keys? The short answer is that it is not necessary thanks to public-key cryptography. But let’s give an example where it might otherwise be necessary to generate all these keys.
</p>
<p>
Say Alice, Bob, and Tom want to communicate privately with one another. How do they distribute keys $k_{AB}$, $k_{AT}$, and $k_{BT}$? Perhaps Alice chooses $k_{AB}$ and $k_{AT}$ and gives them to Bob and Tom in super secret meet ups. But clearly if Alice wants to communicate with $n$ people, meeting all of them in person to give them a secret key is not practical. So instead Alice mails Bob and Tom their secret keys, eliminating the need for super secret meet ups. But Tom is curious about Alice’s private communications with Bob, so Tom intercepts the letter and copies the secret key $k_{AB}$ before forwarding it to Bob. Tom is then able to read all of Alice and Bob’s communications without either of them knowing that he is doing so. This of course undermines the entire reason for setting up a cryptographic communication scheme in the first place.
</p>
<p>
So instead say Alice, Bob, and Tom appeal to a trusted party, Server. Server generates all the secret keys and is always available for super secret meet ups to hand them off in person. The first problem with this distribution scheme is that in the worst case Server will have to generate and maintain $\frac{n(n-1)}{2}$ keys to make sure that he doesn’t accidentally distribute a key to more than one pair of users. The second problem is can Alice, Bob, and Tom really trust Server? Server can read everyone's messages. Again this seems to undermine the entire reason for using a cryptographic communication scheme.
</p>
<p>
Public-key cryptography while much more computationally intensive than symmetric key cryptography avoids the problem of exchanging secret keys entirely. In fact public-key cryptographic schemes are often used to set up secure communication channels via which individuals initially exchange secret keys for symmetric key cryptography schemes.
</p>
<p>
<b>Sources:</b> en.wikipedia.org/wiki/Caesar_cipher
</p>
<hr>
</div>
<div class="hspacer"></div>
</body>
</html>
