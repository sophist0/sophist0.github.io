<html>
<head>
<title>Crypto Notes</title>
<link rel="stylesheet" type="text/css" href="crypto_style.css">
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>

<div class="content_block">
<h1>Crypto Notes</h1>
<hr>
<p>
The goal of these notes is to serve as a record of my own understanding of crypto currencies and related concepts. I find writing formal notes forces me to confront gaps in my understanding. Also I personally do not invest in crypto currencies as I cannot afford to lose the money and I do not suggest that anyone else should except for educational purposes. What interests me about crypto currencies is not so much their value but their relative success as persistent distributed applications. These notes no doubt reflect this interest.
</p>
<p>
I had also hoped that GitHub Pages had some great whizzbang plug and play templates which would make my notes look pro! Not so much, so bear with me as I refine there presentation.
</p>
<h2>Preliminary Concepts</h2>
<hr>

<p>
<h3>Hash Function</h3>
A hash function is a function that,
<ol>
	<li>Maps a message m of arbitrary size to a fixed size hash value, $hash(m)$.</li>
	<li>Scrambles the information in m such that the hash functions hash value is uniformly distributed across its possible values.</li>
	<li>Is fast to compute.</li>
	<li>Is deterministic.</li>
</ol>

Notice that 2. leads to a corollary,
<ul>
<li>A hash function minimizes the probability that two distinct messages $m_1$ and $m_2$ have the same hash value. Which can be formally expressed as minimizing the probability that,
$$
m_1 \neq m_2 	\hspace{2em} \text{and} \hspace{2em} 	hash(m_1) = hash(m_2)
$$
</li>
</ul>

This is a corollary of 2. because 2. states that hash(m) for any message m is uniformly distributed over all possible hash values. Additionally it is called a hash collision if it is true that $m_1 \neq m_2$ and $hash(m_1) = hash(m_2)$.
</p>
<p>
An example of a simple hash function is,<br>
<img src="images/hash_func.png"><br>

Assuming the input message is a string of alphabetic characters this simple hash function outputs an integer between 0 and 4. So if we input messages ALICE and BOB into this hash function we get hashes 0 and 4 as shown in the table below.
</p>
<table style="width:100%">
	<tr class="col_label">
    	<th>Input</th>
    	<th>Current Char.</th> 
    	<th>Char. to Dec.</th>
	<th>(+)</th>
	<th>mod 5</th>
	<th>Output</th>
  	</tr>
	<tr>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
    	<th>None</th>
  	</tr>
	<tr>
    	<th>ALICE</th>
    	<th>A</th>
    	<th>1</th>
    	<th>1</th>
    	<th>1</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>L</th>
    	<th>12</th>
    	<th>13</th>
    	<th>3</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>I</th>
    	<th>9</th>
    	<th>12</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>C</th>
    	<th>3</th>
    	<th>5</th>
    	<th>0</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>E</th>
    	<th>5</th>
    	<th>10</th>
    	<th>0</th>
    	<th>0</th>
  	</tr>
	<tr>
    	<th>BOB</th>
    	<th>B</th>
    	<th>2</th>
    	<th>2</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>O</th>
    	<th>15</th>
    	<th>17</th>
    	<th>2</th>
    	<th></th>
  	</tr>
	<tr>
    	<th></th>
    	<th>B</th>
    	<th>2</th>
    	<th>4</th>
    	<th>4</th>
    	<th>4</th>
  	</tr>
</table>
<p>
<b>Notation:</b> (+) denotes addition, mod denotes the modulo operation<br>
<b>Source:</b> en.wikipedia.org/wiki/Hash_function
</p>

<p>
<h3>Cryptographic Hash Function</h3>
The fundamental difference between a hash function and a cryptographic hash function is that it is practically impossible to invert a cryptographic hash function, which is a one-way function. In life there are many one-way functions. For instance it is easy to light a match, but once lit it is practically impossible to return it to its initial state.
</p>
<p>
In the example hash function above, the inability to invert it would imply that given the hash value $0$ it is impossible to guess that it was derived from the message ALICE. This is clearly not true which is why the hash function above is not a cryptographic hash function.
</p>
Getting more technical a cryptographic hash function should satisfy the following properties.
<ul>
<li>
<b>Pre-image resistance:</b>
Given a hash value $h$ it should be difficult to find a message $m$ such that,
$$
h = hash(m)
$$
</li>
<li>
<b>Second pre-image resistance:</b>
Given an input $m_1$, it should be difficult to find a different input $m_2$ such that,
$$
hash(m_1) = hash(m_2)
$$
</li>
<li>
<b>Collision resistance:</b>
It should be difficult to find two different messages $m_1$ and $m_2$ such that.
$$
hash(m_1) = hash(m_2)
$$
</li>
</ul>
<b>Source:</b> en.wikipedia.org/wiki/Cryptographic_hash_function
</div>
</body>
</html>
